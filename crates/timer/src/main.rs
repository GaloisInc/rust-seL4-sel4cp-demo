#![no_std]
#![no_main]
#![feature(never_type)]

use sel4cp::{memory_region_symbol, protection_domain, Channel, Handler};
use sel4cp::message::{MessageInfo, NoMessageValue, StatusMessageLabel, NoMessageLabel};
use sel4cp::debug_print;

use timer_interface_types::*;

use time::Duration;

use heapless::Vec;

mod device;

use device::{TtcDevice, TtcRegisterBlock};

const TTC0_1: Channel = Channel::new(4);
// TODO: use these channels for sub-ms timing if needed (PWD, usleep, etc)
//const TTC0_2: Channel = Channel::new(5);
//const TTC0_3: Channel = Channel::new(6);

const CLIENT_1: Channel = Channel::new(7);

const MAX_VEC_SIZE: usize = 256;

#[protection_domain]
fn init() -> ThisHandler {
    let ttc0 = unsafe { TtcDevice::new(
        memory_region_symbol!(ttc0_register_block: *mut TtcRegisterBlock).as_ptr(),
    ) };
    ttc0.init();

    ThisHandler {
        ttc0: ttc0,
        clients: {
            let mut v = Vec::<Channel, MAX_VEC_SIZE>::new();
            for c in [CLIENT_1] {
                // NOTE: this is ripe for some autogenerated code that is guaranteed to be correct
                v.push(c).unwrap();
            }
            v
        },
        alarms: Vec::<(Channel,Duration), MAX_VEC_SIZE>::new(),
    }
}

struct ThisHandler {
    ttc0: TtcDevice,
    clients: Vec<Channel, MAX_VEC_SIZE>,
    alarms: Vec<(Channel,Duration), MAX_VEC_SIZE>,
    // NOTE: these would be the periodic calls,
    // probably autogenerated glue code to properly handle this
    // periodic: Vec<(Channel,Duration), MAX_VEC_SIZE>,
}

impl Handler for ThisHandler {
    type Error = !;

    fn notified(&mut self, channel: Channel) -> Result<(), Self::Error> {
        match channel {
            TTC0_1 => {
                self.ttc0.handle_irq();
                TTC0_1.irq_ack().unwrap();
                // handle alarms (sleep)
                let current_time = Duration::milliseconds(self.ttc0.uptime_ms());
                while !self.alarms.is_empty() {
                    match self.alarms.pop() {
                        Some((alarm_channel,alarm_time)) => {
                            if current_time >= alarm_time {
                                // notify the channel, the alarm rings
                                alarm_channel.notify();
                            } else {
                                // put the alarm back, it hasn't expired yet
                                self.alarms.push((alarm_channel,alarm_time)).unwrap();
                                break; // exit the loop
                            }
                        },
                        None => {
                            // this should never happen
                            break;
                        }
                    }
                }
                // handle periodic calls
                // TODO: similar as sleep alarms, just need to repeat
            }
            _ => {
                debug_print!("[Timer] Unexpected notification from channel: {:?}\n",channel);
            }
        }
        Ok(())
    }

    fn protected(
        &mut self,
        channel: Channel,
        msg_info: MessageInfo,
    ) -> Result<MessageInfo, Self::Error> {
        if self.clients.contains(&channel) {
            match msg_info.label().try_into().ok() /* XXX Handle errors? */ {
                Some(TimerRequest::Sleep) => {
                    match msg_info.recv() {
                        Ok(SleepRequest { ms }) => {
                            if self.alarms.is_full() {
                                // return an error
                                return Ok(MessageInfo::send(StatusMessageLabel::Error, NoMessageValue))
                            } else {
                                // insert a new alarm
                                self.alarms.push((channel, Duration::milliseconds(self.ttc0.uptime_ms() + ms))).unwrap();
                                // sort the alarm time in ascending order
                                self.alarms.sort_unstable_by(|(_,a1), (_,a2)| a1.cmp(a2));
                                return Ok(MessageInfo::send(StatusMessageLabel::Ok, NoMessageValue))
                            }
                        },
                        _ => {
                            debug_print!("[Timer] Error getting SleepRequest\n",)
                        },
                    }
                },
                Some(TimerRequest::Uptime) => {
                    // send current uptime
                    return Ok(MessageInfo::send(TimerRequest::Uptime, UptimeValue { millis: self.ttc0.uptime_ms() }))
                }
                _ => {
                    debug_print!("[Timer] Unknown message label!\n",)
                },
            }
        } else {
            debug_print!("[Timer] Unexpected channel!\n",)
        }
        Ok(MessageInfo::send(NoMessageLabel, NoMessageValue))
    }
}
