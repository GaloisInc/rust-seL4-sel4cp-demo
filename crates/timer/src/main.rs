#![no_std]
#![no_main]
#![feature(never_type)]

use sel4cp::{memory_region_symbol, protection_domain, Channel, Handler};
use sel4cp::message::{MessageInfo, NoMessageValue, StatusMessageLabel, NoMessageLabel};
use sel4cp::debug_print;

use timer_interface_types::*;

use heapless::Vec;

use core::ptr;

mod device;

use device::{TtcDevice, TtcRegisterBlock};

const TTC0_1: Channel = Channel::new(4);
const TTC0_2: Channel = Channel::new(5);
const TTC0_3: Channel = Channel::new(6);

const CLIENT_1: Channel = Channel::new(7);

const MAX_VEC_SIZE: usize = 256;

#[protection_domain]
fn init() -> ThisHandler {
    let ttc0 = unsafe { TtcDevice::new(
        memory_region_symbol!(ttc0_register_block: *mut TtcRegisterBlock).as_ptr(),
    ) };
    ttc0.init();

    let irqs = Vec::<Channel, 8>::new();
    ThisHandler {
        ttc0: ttc0,
        irqs: {
            let mut v = Vec::<Channel, MAX_VEC_SIZE>::new();
            for c in [TTC0_1,TTC0_2,TTC0_3] {
                // NOTE: this is ripe for some autogenerated code that is guaranteed to be correct
                v.push(c).unwrap();
            }
            v
        },
        clients: {
            let mut v = Vec::<Channel, MAX_VEC_SIZE>::new();
            for c in [CLIENT_1] {
                // NOTE: this is ripe for some autogenerated code that is guaranteed to be correct
                v.push(c).unwrap();
            }
            v
        },
    }
}

struct ThisHandler {
    ttc0: TtcDevice,
    irqs: Vec<Channel, MAX_VEC_SIZE>,
    clients: Vec<Channel, MAX_VEC_SIZE>,
}


impl Handler for ThisHandler {
    type Error = !;

    fn notified(&mut self, channel: Channel) -> Result<(), Self::Error> {
        match channel {
            TTC0_1 => {
                self.ttc0.handle_irq();
                TTC0_1.irq_ack().unwrap();
                // handle timers / wake up calls
            }
            _ => {
                debug_print!("[Timer] Unexpected notification from channel: {:?}\n",channel);
            }
        }
        Ok(())
    }

    fn protected(
        &mut self,
        channel: Channel,
        msg_info: MessageInfo,
    ) -> Result<MessageInfo, Self::Error> {
        match msg_info.label().try_into().ok() /* XXX Handle errors? */ {
            Some(TimerTag::Sleep) => {
                match msg_info.recv() {
                    Ok(SleepRequest { ms }) => {
                        // TODO: sleep for ms
                    },
                    _ => {},
                }
            },
            Some(TimerTag::Uptime) => {
                // send current uptime
                return Ok(MessageInfo::send(TimerTag::Uptime, UptimeValue { seconds: 1, nanoseconds: 2 }))
            }
            _ => {
                debug_print!("[Timer] Unknown message label!\n",)
            },
        }
        Ok(MessageInfo::send(NoMessageLabel, NoMessageValue))
        // Interface
        // uptime (duration)
        // msleep (duration)
    }
}
